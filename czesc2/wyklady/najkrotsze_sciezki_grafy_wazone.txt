G = (V,E) - graf (skierowany lub nie)
[Na razie zakładamy wagi nieujemne]
Reprezantacja macierzowa:
    W - macierz wag
    W[i][j[ = w({v1,v2})
    W[i][j] = inf #gdy krawedz nie istnieje
Reprezetacja listowa:
    Node z wierzcholkiem przechowuje wierzcholek i wage

Warianty szukania najkrótszych ścieżek:
    1. "1 do 1" (z punktu widzenia algorytmiki klasycznej trudne do wykorzystania)
    2. "1 do wszyscy" np. BFS. Dijkstry, Belmana-Forda
    3. "wszyscy do wszyscy" np. FLoyda-Warschalla

Algorytm podstawowy/BFS:
    BFS szuka najkrotszej sciezki na podstawie liczby wierzcholkow, ktory dziala tak se jak dodajemy sztuczne wierzcholki
    dlatego musimy go zmodyfikować: ALGORYTM DIJKSTRY!!!

''' ALGROYTM PODSTAWOWY, ale:
    a)skacze bezposrednio do "waznych" wierzcholkow
    b)nie wymaga liczb naturalnych, ale wymaga nieujemnych

G = (V,E)
s - wierzcholek startowy
v.d oszacowanie odleglosci od s
v.parent - poprzednik

ALGORYTM:   zlozonosc czasowa: O(ElogV)  (dla rezprezentacji macierzowej lepiej zrobic O(V^2))
    1. Wszystkie wierzchołki otrzymują wartość v.d = inf i są utrzymywane w kolejce priorytetowej
    2. s.d = 0 (uaktualnia kolejkę)
    3. Wyciągamy z kolejki Q wierzchołek u o min wartosci u.d
    dla kazdej krawedzi z u do v wykojnemy relaksację (proste wymuszenie nierownosci trojkata)
    def relax(u,v):
        if u.d + w(u,v) < v.d:
            v.d = u.d + w(u,v)
            v.parent = u


tw. w momencie gdy alg. Dijkstry wyciąga wierzcholek u z kolejki to wartosc u.d jest rowna najmniejszej odleglosci
'''
